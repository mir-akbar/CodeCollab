const express = require("express");
const multer = require("multer");
const path = require("path");
const unzipper = require("unzipper");
const cors = require("cors");
const { Readable } = require("stream");
const { Buffer } = require("buffer");
const fileStorageService = require("../services/fileStorageService");
const accessService = require("../services/accessService");

const router = express.Router();

router.use(cors({
  origin: "*",
  methods: ["GET", "POST"],
}));

// Use memory storage for processing
const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 50 * 1024 * 1024 }, // 50MB limit
});

module.exports = (io) => {
  router.post("/file-upload", upload.single("file"), async (req, res) => {
    // Comprehensive input validation
    if (!req.file) {
      return res.status(400).json({ 
        error: "No file uploaded",
        hint: "Please select a file to upload"
      });
    }

    const { sessionID, email } = req.body;
    
    // Validate required fields
    if (!sessionID) {
      return res.status(400).json({ 
        error: "Session ID is required",
        hint: "Please provide a valid session ID"
      });
    }
    
    if (!email) {
      return res.status(400).json({ 
        error: "User email is required",
        hint: "Please provide a valid email address"
      });
    }

    // File validation
    const fileExt = path.extname(req.file.originalname).toLowerCase();
    const allowedExtensions = [".js", ".java", ".py", ".zip"];
    
    // Check file size (50MB limit already set in multer, but add user-friendly error)
    const maxFileSize = 50 * 1024 * 1024; // 50MB
    if (req.file.size > maxFileSize) {
      return res.status(400).json({
        error: `File too large: ${(req.file.size / (1024 * 1024)).toFixed(2)}MB`,
        hint: `Maximum file size is ${maxFileSize / (1024 * 1024)}MB`,
        fileName: req.file.originalname
      });
    }

    console.log(`ğŸ“¤ Processing upload: ${req.file.originalname} (${(req.file.size / 1024).toFixed(2)}KB) for session ${sessionID}`);

    // Validate session access
    try {
      // Check if user has editor permission for file uploads
      const hasAccess = await accessService.checkSessionAccess(sessionID, email, 'editor');
      if (!hasAccess) {
        return res.status(403).json({ 
          error: "Access denied: User needs editor permission to upload files to this session",
          hint: "Contact the session owner to get editor access"
        });
      }

      console.log(`âœ… Session access validated for user ${email} in session ${sessionID}`);

    } catch (error) {
      console.error("Session validation error:", error);
      return res.status(500).json({ 
        error: "Failed to validate session access", 
        details: error.message,
        hint: "Please try again or contact support if the issue persists"
      });
    }

    try {
      let fileResponse;

      if (fileExt === ".zip") {
        // Handle ZIP file extraction with progressive updates
        console.log(`ğŸ“¦ Starting ZIP extraction for ${req.file.originalname}...`);
        
        // Emit initial upload event
        io.emit("zipUploadStarted", { 
          sessionID, 
          fileName: req.file.originalname,
          fileSize: req.file.size,
          message: "ZIP file processing started..." 
        });
        
        try {
          const extractedFiles = await handleZipFile(req.file, sessionID, io, email);

          console.log(`âœ… ZIP file extraction completed: ${extractedFiles.length} files processed`);

          fileResponse = {
            message: "ZIP file uploaded and extracted successfully",
            files: extractedFiles,
            sessionID,
            totalFiles: extractedFiles.length,
            originalFileName: req.file.originalname
          };
        } catch (zipError) {
          console.error("ZIP extraction failed:", zipError);
          return res.status(500).json({
            error: "ZIP file extraction failed",
            details: zipError.message,
            fileName: req.file.originalname,
            hint: "Please check that the ZIP file is not corrupted and contains supported file types (.js, .java, .py)"
          });
        }

      } else if (allowedExtensions.includes(fileExt)) {
        // Handle individual file
        try {
          const savedFile = await fileStorageService.storeFile({
            sessionId: sessionID,
            fileName: req.file.originalname,
            fileType: fileExt,
            content: req.file.buffer,
            mimeType: req.file.mimetype || 'text/plain',
            parentFolder: null,
            filePath: req.file.originalname,
            uploadedBy: email // Add uploader info
          });

          console.log("âœ… Single file uploaded to MongoDB:", savedFile.fileName);

          fileResponse = {
            message: "File uploaded successfully",
            files: [
              {
                name: savedFile.fileName,
                type: savedFile.fileType.replace('.', ''),
                path: savedFile.filePath,
                size: savedFile.fileSize,
                uploadedBy: email
              }
            ],
            sessionID
          };

        } catch (fileError) {
          console.error("Error storing individual file:", fileError);
          return res.status(500).json({ 
            error: "Failed to store file", 
            details: fileError.message,
            fileName: req.file.originalname
          });
        }

      } else {
        return res.status(400).json({ 
          error: `Unsupported file type: ${fileExt}`,
          supportedTypes: allowedExtensions,
          fileName: req.file.originalname
        });
      }

      res.json(fileResponse);
      
      // Emit socket events for real-time updates
      console.log(`ğŸ“¡ Emitting final socket events for session ${sessionID}`);
      
      if (fileExt === ".zip") {
        // For ZIP files, the comprehensive events are already emitted in handleZipFile
        // Just emit a final confirmation
        io.emit("zipUploadComplete", {
          ...fileResponse,
          message: `ZIP upload complete: ${fileResponse.files.length} files added`
        });
        
      } else {
        // For single files, emit standard events
        io.emit("fileUploaded", fileResponse);
        
        // Also emit to session-specific room for any listeners
        io.to(sessionID).emit("filesChanged", { 
          sessionId: sessionID, 
          files: fileResponse.files,
          action: "single_upload"
        });
      }
      
      console.log(`âœ… Socket events emitted successfully for session ${sessionID}`);

    } catch (error) {
      console.error("Error processing file:", error);
      res.status(500).json({ 
        error: "File processing failed", 
        details: error.message 
      });
    }
  });

  // Helper function to check if file should be ignored
  function shouldIgnoreFile(filePath) {
    const fileName = path.basename(filePath);
    const dirName = path.dirname(filePath);
    
    // Ignore macOS system files
    if (fileName.startsWith('._') || fileName === '.DS_Store') {
      return true;
    }
    
    // Ignore __MACOSX directory and its contents
    if (dirName.includes('__MACOSX') || filePath.includes('__MACOSX/')) {
      return true;
    }
    
    // Ignore other common system/hidden files
    const ignoredPatterns = [
      '.git/', 'node_modules/', '.vscode/', '.idea/',
      'Thumbs.db', 'desktop.ini', '.env', '.env.local'
    ];
    
    return ignoredPatterns.some(pattern => 
      filePath.includes(pattern) || fileName === pattern.replace('/', '')
    );
  }

  async function handleZipFile(zipFile, sessionID, io, uploaderEmail) {
    const extractedFiles = [];
    const filePromises = [];
    let totalFiles = 0;
    let processedFiles = 0;
    
    console.log(`ğŸ“¦ Starting ZIP extraction for session ${sessionID}, uploaded by ${uploaderEmail}`);
    
    return new Promise((resolve, reject) => {
      const readable = Readable.from(zipFile.buffer);
      
      readable
        .pipe(unzipper.Parse())
        .on('entry', (entry) => {
          const fileName = entry.path;
          const fileExtension = path.extname(fileName).toLowerCase();
          
          // Skip unwanted system files
          if (shouldIgnoreFile(fileName)) {
            console.log(`ğŸš« Skipping system file: ${fileName}`);
            entry.autodrain();
            return;
          }
          
          if (['.js', '.java', '.py'].includes(fileExtension)) {
            totalFiles++;
            console.log(`ğŸ“„ Found valid file ${totalFiles}: ${fileName}`);
            
            // Create a promise for each file processing
            const filePromise = new Promise((resolveFile, rejectFile) => {
              const chunks = [];
              
              entry.on('data', (chunk) => chunks.push(chunk));
              entry.on('end', async () => {
                try {
                  const content = Buffer.concat(chunks);
                  const parentFolder = path.dirname(fileName) !== '.' ? path.dirname(fileName) : null;
                  const baseFileName = path.basename(fileName);
                  const normalizedFilePath = fileName.replace(/\\/g, '/');
                  
                  console.log(`ğŸ’¾ Storing file: ${baseFileName} (${content.length} bytes)`);
                  
                  const savedFile = await fileStorageService.storeFile({
                    sessionId: sessionID,
                    fileName: baseFileName,
                    fileType: fileExtension,
                    content,
                    mimeType: 'text/plain',
                    parentFolder,
                    filePath: normalizedFilePath,
                    uploadedBy: uploaderEmail
                  });
                  
                  const fileInfo = {
                    name: savedFile.fileName,
                    type: savedFile.fileType.replace('.', ''),
                    path: savedFile.filePath,
                    size: savedFile.fileSize,
                    uploadedBy: uploaderEmail
                  };
                  
                  extractedFiles.push(fileInfo);
                  processedFiles++;
                  
                  console.log(`âœ… File stored successfully: ${baseFileName} (${processedFiles}/${totalFiles})`);
                  
                  // Emit progress update for each file processed
                  io.emit("zipFileProcessed", { 
                    sessionID, 
                    file: fileInfo,
                    processedFiles, 
                    totalFiles,
                    message: `Processed ${processedFiles}/${totalFiles} files` 
                  });
                  
                  resolveFile(fileInfo);
                  
                } catch (error) {
                  const baseFileName = path.basename(fileName);
                  console.error(`âŒ Error storing extracted file ${baseFileName}:`, error);
                  rejectFile({
                    fileName: baseFileName,
                    error: error.message,
                    details: error
                  });
                }
              });
              
              entry.on('error', (error) => {
                console.error(`âŒ Error reading file ${fileName}:`, error);
                rejectFile({
                  fileName: path.basename(fileName),
                  error: error.message,
                  details: error
                });
              });
            });
            
            filePromises.push(filePromise);
          } else {
            entry.autodrain();
          }
        })
        .on('close', async () => {
          try {
            console.log(`ğŸ“¥ ZIP parsing complete. Processing ${filePromises.length} files...`);
            
            // Emit initial progress update with total files found
            io.emit("zipProgress", { 
              sessionID, 
              totalFiles: filePromises.length,
              message: `ZIP parsing complete. Processing ${filePromises.length} files...` 
            });
            
            // Process files with error recovery - use Promise.allSettled instead of Promise.all
            const results = await Promise.allSettled(filePromises);
            
            // Separate successful and failed uploads
            const successfulFiles = [];
            const failedFiles = [];
            
            results.forEach((result, index) => {
              if (result.status === 'fulfilled') {
                successfulFiles.push(result.value);
              } else {
                failedFiles.push({
                  fileName: `file_${index}`,
                  error: result.reason?.message || 'Unknown error'
                });
                console.error(`âŒ Failed to process file ${index}:`, result.reason);
              }
            });
            
            console.log(`ğŸ‰ ZIP processing complete: ${successfulFiles.length} successful, ${failedFiles.length} failed`);
            
            // Update extractedFiles with only successful ones
            extractedFiles.length = 0; // Clear array
            extractedFiles.push(...successfulFiles);
            
            // Get the complete updated file list for the session
            const allSessionFiles = await fileStorageService.getSessionFiles(sessionID);
            const transformedFiles = allSessionFiles.map(file => ({
              name: file.fileName,
              type: file.fileType.replace('.', ''),
              path: file.filePath,
              size: file.fileSize
            }));
            
            // Emit completion event with comprehensive file list and error info
            const completionMessage = failedFiles.length > 0 
              ? `ZIP extraction complete! ${successfulFiles.length} files added, ${failedFiles.length} failed.`
              : `ZIP extraction complete! ${successfulFiles.length} files added.`;
              
            io.emit("zipExtractionComplete", { 
              sessionID, 
              totalFiles: successfulFiles.length,
              files: extractedFiles,
              failedFiles: failedFiles,
              message: completionMessage
            });
            
            // Emit session update with all files (most important for sidebar)
            io.emit("sessionFilesUpdated", { 
              sessionID, 
              files: transformedFiles,
              message: `Session updated: ${transformedFiles.length} total files`
            });
            
            resolve(extractedFiles);
          } catch (error) {
            console.error('âŒ Error processing ZIP files:', error);
            reject(error);
          }
        })
        .on('error', (error) => {
          console.error('âŒ ZIP parsing error:', error);
          reject(error);
        });
    });
  }

  return router;
};
