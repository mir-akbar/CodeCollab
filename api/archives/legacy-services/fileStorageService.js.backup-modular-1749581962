/**
 * Pure Y-WebSocket File Storage Service
 * Complete file management solution optimized for real-time Y-WebSocket collaboration
 * Handles MongoDB persistence with Y-WebSocket room notifications
 */

const FileStorage = require('../models/FileStorage');
const path = require('path');

class PureYjsFileStorageService {
  constructor() {
    this.yjsServer = null;
    this.uploadSessions = new Map(); // Track active uploads
    this.SUPPORTED_TYPES = [
      'javascript', 'python', 'java', 'cpp', 'html', 'css', 
      'json', 'xml', 'yaml', 'markdown', 'txt', 'env'
    ];
  }

  /**
   * Set Y-WebSocket server (required for real-time collaboration)
   */
  setYjsServer(yjsServer) {
    this.yjsServer = yjsServer;
    console.log('ðŸ”Œ Y-WebSocket server connected to file storage service');
  }

  /**
   * Upload single file with Y-WebSocket real-time collaboration setup
   */
  async uploadFile(sessionId, fileData, uploaderEmail) {
    const uploadId = `upload-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    if (!this.yjsServer) {
      throw new Error('Y-WebSocket server required for file uploads');
    }
    
    try {
      console.log(`ðŸ“¤ Starting Y-WebSocket file upload: ${fileData.fileName} for session ${sessionId}`);
      
      // Store file in MongoDB
      const savedFile = await this.storeFile({
        sessionId,
        fileName: fileData.fileName,
        fileType: fileData.fileType,
        content: fileData.content,
        mimeType: fileData.mimeType,
        parentFolder: fileData.parentFolder,
        filePath: fileData.filePath,
        uploadedBy: uploaderEmail
      });

      // Create file info for response
      const fileInfo = {
        id: savedFile._id.toString(),
        name: savedFile.fileName,
        type: savedFile.fileType.replace('.', ''),
        path: savedFile.filePath,
        size: savedFile.fileSize,
        uploadedBy: uploaderEmail,
        uploadedAt: new Date().toISOString()
      };
      
      // Notify Y-WebSocket room about new file for collaboration
      const roomName = `${sessionId}-${fileData.fileName}`;
      this.yjsServer.broadcastToRoom(roomName, {
        type: 'file-ready-for-collaboration',
        sessionId,
        file: fileInfo,
        message: `File uploaded and ready for real-time editing: ${fileData.fileName}`
      });
      
      console.log(`âœ… File stored and Y-WebSocket room notified: ${fileData.fileName}`);
      
      return {
        success: true,
        file: fileInfo,
        uploadId,
        collaborationReady: true
      };
      
    } catch (error) {
      console.error(`âŒ Y-WebSocket file upload failed: ${fileData.fileName}`, error);
      throw error;
    }
  }

  /**
   * Upload ZIP file with Y-WebSocket real-time collaboration setup
   */
  async uploadZipFile(sessionId, zipFile, uploaderEmail) {
    const uploadId = `zip-upload-${Date.now()}`;
    
    if (!this.yjsServer) {
      throw new Error('Y-WebSocket server required for ZIP uploads');
    }
    
    try {
      console.log(`ðŸ“¦ Starting Y-WebSocket ZIP upload for session ${sessionId}`);
      
      // Extract and process files
      const extractedFiles = await this.processZipFile(
        zipFile, 
        sessionId, 
        uploaderEmail
      );

      // Notify Y-WebSocket rooms about all new files for collaboration
      extractedFiles.forEach(file => {
        const roomName = `${sessionId}-${file.name}`;
        this.yjsServer.broadcastToRoom(roomName, {
          type: 'file-ready-for-collaboration',
          sessionId,
          file,
          message: `ZIP file extracted: ${file.name} ready for collaboration`
        });
      });

      console.log(`âœ… ZIP processing complete: ${extractedFiles.length} files extracted and Y-WebSocket rooms notified`);
      
      return {
        success: true,
        files: extractedFiles,
        uploadId,
        totalFiles: extractedFiles.length,
        collaborationReady: true
      };
      
    } catch (error) {
      console.error('âŒ Y-WebSocket ZIP upload failed:', error);
      throw error;
    }
  }

  /**
   * Process ZIP file with progress tracking
   */
  async processZipFile(zipFile, sessionId, uploaderEmail) {
    const unzipper = require('unzipper');
    const { Readable } = require('stream');
    
    const extractedFiles = [];
    const filePromises = [];
    let totalFiles = 0;
    let processedFiles = 0;
    
    console.log(`ðŸ“¦ Starting ZIP extraction for session ${sessionId}`);
    
    return new Promise((resolve, reject) => {
      const readable = Readable.from(zipFile.buffer);
      
      readable
        .pipe(unzipper.Parse())
        .on('entry', (entry) => {
          const fileName = entry.path;
          const fileExtension = path.extname(fileName).toLowerCase();
          
          // Skip system files
          if (this.shouldIgnoreFile(fileName)) {
            console.log(`ðŸš« Skipping system file: ${fileName}`);
            entry.autodrain();
            return;
          }
          
          if (['.js', '.java', '.py'].includes(fileExtension)) {
            totalFiles++;
            console.log(`ðŸ“„ Found valid file ${totalFiles}: ${fileName}`);
            
            const filePromise = this.processZipEntry(
              entry, 
              fileName, 
              fileExtension, 
              sessionId, 
              uploaderEmail
            ).then((fileInfo) => {
              processedFiles++;
              console.log(`âœ… File processed: ${fileName} (${processedFiles}/${totalFiles})`);
              extractedFiles.push(fileInfo);
              return fileInfo;
            }).catch((error) => {
              processedFiles++;
              console.error(`âŒ Failed to process file ${fileName}:`, error);
              // Continue processing other files
              return null;
            });
            
            filePromises.push(filePromise);
          } else {
            entry.autodrain();
          }
        })
        .on('close', async () => {
          try {
            console.log(`ðŸ“¥ ZIP parsing complete. Processing ${filePromises.length} files...`);
            
            // Wait for all files to be processed (with error recovery)
            const results = await Promise.allSettled(filePromises);
            
            // Filter out failed uploads
            const successfulFiles = results
              .filter(result => result.status === 'fulfilled' && result.value)
              .map(result => result.value);
            
            console.log(`ðŸŽ‰ ZIP extraction complete: ${successfulFiles.length} files added`);
            resolve(successfulFiles);
          } catch (error) {
            reject(error);
          }
        })
        .on('error', (error) => {
          console.error('âŒ ZIP parsing error:', error);
          reject(error);
        });
    });
  }

  /**
   * Process individual ZIP entry
   */
  async processZipEntry(entry, fileName, fileExtension, sessionId, uploaderEmail) {
    return new Promise((resolve, reject) => {
      const chunks = [];
      
      entry.on('data', (chunk) => chunks.push(chunk));
      entry.on('end', async () => {
        try {
          const content = Buffer.concat(chunks);
          const baseFileName = path.basename(fileName);
          const normalizedFilePath = fileName.replace(/\\/g, '/');
          const parentFolder = path.dirname(fileName) !== '.' ? path.dirname(fileName) : null;
          
          console.log(`ðŸ’¾ Storing file: ${baseFileName} (${content.length} bytes)`);
          
          // Store in MongoDB using our own storeFile method
          const savedFile = await this.storeFile({
            sessionId,
            fileName: baseFileName,
            fileType: fileExtension,
            content,
            mimeType: 'text/plain',
            parentFolder,
            filePath: normalizedFilePath,
            uploadedBy: uploaderEmail
          });
          
          const fileInfo = {
            id: savedFile._id.toString(),
            name: savedFile.fileName,
            type: savedFile.fileType.replace('.', ''),
            path: savedFile.filePath,
            size: savedFile.fileSize,
            uploadedBy: uploaderEmail,
            uploadedAt: new Date().toISOString()
          };
          
          resolve(fileInfo);
        } catch (error) {
          reject(error);
        }
      });
      
      entry.on('error', reject);
    });
  }

  /**
   * Store a new file
   */
  async storeFile(fileData) {
    try {
      // Validate required fields
      if (!fileData.sessionId || !fileData.fileName || !fileData.content) {
        throw new Error('Missing required fields: sessionId, fileName, or content');
      }

      // Generate file path if not provided
      const filePath = fileData.filePath || fileData.fileName;
      
      // Determine file type from extension
      const fileExtension = path.extname(fileData.fileName).toLowerCase().slice(1);
      const fileType = this._getFileType(fileExtension);

      // Create file document
      const file = new FileStorage({
        sessionId: fileData.sessionId,
        fileName: fileData.fileName,
        filePath: filePath,
        fileType: fileType,
        content: Buffer.isBuffer(fileData.content) ? fileData.content : Buffer.from(fileData.content, 'utf8'),
        fileSize: Buffer.byteLength(fileData.content),
        mimeType: fileData.mimeType || this._getMimeType(fileExtension),
        uploadedBy: fileData.uploadedBy || fileData.cognitoId
      });

      await file.save();
      return file;
    } catch (error) {
      console.error('Error storing file:', error);
      throw error;
    }
  }

  /**
   * Get file by session and path
   */
  async getFile(sessionId, filePath) {
    try {
      const file = await FileStorage.findByPath(sessionId, filePath);
      if (!file) {
        throw new Error('File not found');
      }
      return file;
    } catch (error) {
      console.error('Error getting file:', error);
      throw error;
    }
  }

  /**
   * Update file content
   */
  async updateFileContent(sessionId, filePath, newContent, cognitoId = null) {
    try {
      const file = await FileStorage.findByPath(sessionId, filePath);
      if (!file) {
        throw new Error('File not found');
      }

      // Update content and metadata
      file.content = Buffer.isBuffer(newContent) ? newContent : Buffer.from(newContent, 'utf8');
      file.fileSize = Buffer.byteLength(file.content);
      file.updatedAt = new Date();
      
      if (cognitoId) {
        file.uploadedBy = cognitoId;
      }

      await file.save();
      return file;
    } catch (error) {
      console.error('Error updating file content:', error);
      throw error;
    }
  }

  /**
   * Delete a file
   */
  async deleteFile(sessionId, filePath) {
    try {
      const result = await FileStorage.deleteOne({ sessionId, filePath });
      return result.deletedCount > 0;
    } catch (error) {
      console.error('Error deleting file:', error);
      throw error;
    }
  }

  /**
   * Delete folder and all its contents
   */
  async deleteFolder(sessionId, folderPath) {
    try {
      const result = await FileStorage.deleteMany({ 
        sessionId, 
        $or: [
          { filePath: folderPath },
          { filePath: { $regex: `^${folderPath}/` } }
        ]
      });
      return result.deletedCount;
    } catch (error) {
      console.error('Error deleting folder:', error);
      throw error;
    }
  }

  /**
   * Get all files in a session
   */
  async getSessionFiles(sessionId) {
    try {
      return await FileStorage.find({ sessionId })
        .select('-content') // Exclude content for listing
        .sort({ filePath: 1 });
    } catch (error) {
      console.error('Error getting session files:', error);
      throw error;
    }
  }

  /**
   * Get file hierarchy for session
   */
  async getFileHierarchy(sessionId) {
    try {
      const files = await this.getSessionFiles(sessionId);
      return this._buildHierarchy(files);
    } catch (error) {
      console.error('Error building file hierarchy:', error);
      throw error;
    }
  }

  /**
   * Delete all files for a session
   */
  async deleteSession(sessionId) {
    try {
      const result = await FileStorage.deleteMany({ sessionId });
      return result.deletedCount;
    } catch (error) {
      console.error('Error deleting session files:', error);
      throw error;
    }
  }

  /**
   * Get storage statistics for a session
   */
  async getStorageStats(sessionId) {
    try {
      const pipeline = [
        { $match: { sessionId } },
        {
          $group: {
            _id: null,
            totalFiles: { $sum: 1 },
            totalSize: { $sum: '$fileSize' }
          }
        }
      ];

      const result = await FileStorage.aggregate(pipeline);
      
      if (result.length === 0) {
        return {
          totalFiles: 0,
          totalSize: 0
        };
      }

      return result[0];
    } catch (error) {
      console.error('Error getting storage stats:', error);
      throw error;
    }
  }

  /**
   * Y-WebSocket Document Synchronization - sync Y.js document state to file
   * Enhanced for pure Y-WebSocket collaboration with room notifications
   */
  async syncYjsDocumentToFile(sessionId, filePath, yjsDocumentState, cognitoId = null) {
    if (!this.yjsServer) {
      throw new Error('Y-WebSocket server required for document synchronization');
    }

    try {
      console.log(`ðŸ”„ Y-WebSocket: Syncing document to file ${filePath} in session ${sessionId}`);
      
      // Convert Y.js document state to text content
      const Y = require('yjs');
      const doc = new Y.Doc();
      Y.applyUpdate(doc, new Uint8Array(yjsDocumentState));
      const ytext = doc.getText('monaco');
      const content = ytext.toString();
      
      // Update the file content in MongoDB
      const updatedFile = await this.updateFileContent(sessionId, filePath, content, cognitoId);
      
      // Notify Y-WebSocket room about document synchronization
      const roomId = `${sessionId}-${filePath}`;
      if (this.yjsServer.hasRoom(roomId)) {
        this.yjsServer.broadcastToRoom(roomId, {
          type: 'file-synced',
          sessionId,
          filePath,
          syncedBy: cognitoId || 'system',
          timestamp: new Date().toISOString()
        });
        console.log(`ðŸ“¡ Y-WebSocket: Notified room ${roomId} about file synchronization`);
      }
      
      return updatedFile;
    } catch (error) {
      console.error('âŒ Y-WebSocket: Error syncing document to file:', error);
      throw error;
    }
  }

  /**
   * Y-WebSocket Document Synchronization - get Y.js document state from file
   * Enhanced for pure Y-WebSocket collaboration with room setup
   */
  async getYjsDocumentFromFile(sessionId, filePath) {
    if (!this.yjsServer) {
      throw new Error('Y-WebSocket server required for document retrieval');
    }

    try {
      console.log(`ðŸ“¥ Y-WebSocket: Retrieving document from file ${filePath} in session ${sessionId}`);
      
      let content = '';
      
      try {
        // Try to get the file content from MongoDB
        const file = await this.getFile(sessionId, filePath);
        content = file.content.toString('utf8');
        console.log(`ðŸ“„ Y-WebSocket: Retrieved file content (${content.length} characters)`);
      } catch (error) {
        // If file doesn't exist, start with empty content
        if (error.message === 'File not found') {
          content = '';
          console.log(`ðŸ“ Y-WebSocket: File not found, starting with empty content`);
        } else {
          throw error;
        }
      }

      // Create Y.js document with the content
      const Y = require('yjs');
      const doc = new Y.Doc();
      const ytext = doc.getText('monaco');
      
      if (content.length > 0) {
        ytext.insert(0, content);
      }
      
      // Ensure Y-WebSocket room exists for this file
      const roomId = `${sessionId}-${filePath}`;
      if (!this.yjsServer.hasRoom(roomId)) {
        this.yjsServer.createRoom(roomId);
        console.log(`ðŸ  Y-WebSocket: Created room ${roomId} for file collaboration`);
      }
      
      // Notify Y-WebSocket room about document retrieval
      this.yjsServer.broadcastToRoom(roomId, {
        type: 'document-loaded',
        sessionId,
        filePath,
        contentLength: content.length,
        timestamp: new Date().toISOString()
      });
      
      // Return the document state as a Uint8Array
      const documentState = Y.encodeStateAsUpdate(doc);
      console.log(`ðŸ”„ Y-WebSocket: Document state prepared for room ${roomId}`);
      
      return documentState;
    } catch (error) {
      console.error('âŒ Y-WebSocket: Error getting document from file:', error);
      throw error;
    }
  }

  /**
   * Store multiple extracted files (for zip uploads)
   */
  async storeExtractedFiles(sessionId, extractedFiles, cognitoId = null) {
    const savedFiles = [];

    for (const fileInfo of extractedFiles) {
      try {
        // Skip system files
        if (this.shouldIgnoreFile(fileInfo.filePath, fileInfo.fileName)) {
          console.log(`ðŸš« Ignoring system file: ${fileInfo.fileName}`);
          continue;
        }

        const savedFile = await this.storeFile({
          sessionId,
          fileName: fileInfo.fileName,
          fileType: fileInfo.fileType,
          content: fileInfo.content,
          mimeType: fileInfo.mimeType || 'text/plain',
          filePath: fileInfo.filePath,
          uploadedBy: cognitoId
        });

        savedFiles.push({
          name: savedFile.fileName,
          type: savedFile.fileType,
          path: savedFile.filePath,
          size: savedFile.fileSize
        });
      } catch (error) {
        console.error(`Error storing file ${fileInfo.fileName}:`, error.message);
      }
    }

    return savedFiles;
  }

  /**
   * Check if file should be ignored (system files)
   */
  shouldIgnoreFile(filePath, fileName) {
    // Use fileName if provided, otherwise extract from filePath
    const name = fileName || path.basename(filePath);
    
    // Ignore macOS system files
    if (name.startsWith('._') || name === '.DS_Store') {
      return true;
    }
    
    // Ignore __MACOSX directory and its contents
    if (filePath.includes('__MACOSX/') || filePath.includes('__MACOSX\\')) {
      return true;
    }
    
    // Ignore other common system/hidden files
    const ignoredPatterns = [
      '.git/', 'node_modules/', '.vscode/', '.idea/',
      'Thumbs.db', 'desktop.ini', '.env', '.env.local',
      '.gitignore', '.gitkeep'
    ];
    
    return ignoredPatterns.some(pattern => 
      filePath.includes(pattern) || name === pattern.replace('/', '')
    );
  }

  // ===== PRIVATE HELPER METHODS =====

  /**
   * Determine file type from extension
   */
  _getFileType(extension) {
    const typeMap = {
      'js': 'javascript',
      'mjs': 'javascript',
      'jsx': 'javascript',
      'ts': 'typescript',
      'tsx': 'typescript',
      'py': 'python',
      'java': 'java',
      'cpp': 'cpp',
      'c': 'cpp',
      'h': 'cpp',
      'hpp': 'cpp',
      'html': 'html',
      'htm': 'html',
      'css': 'css',
      'scss': 'css',
      'sass': 'css',
      'json': 'json',
      'xml': 'xml',
      'yaml': 'yaml',
      'yml': 'yaml',
      'md': 'markdown',
      'txt': 'txt',
      'env': 'env'
    };

    return typeMap[extension] || 'text';
  }

  /**
   * Get MIME type from extension
   */
  _getMimeType(extension) {
    const mimeMap = {
      'js': 'application/javascript',
      'mjs': 'application/javascript',
      'jsx': 'application/javascript',
      'ts': 'application/typescript',
      'tsx': 'application/typescript',
      'py': 'text/x-python',
      'java': 'text/x-java',
      'cpp': 'text/x-c++src',
      'c': 'text/x-csrc',
      'h': 'text/x-chdr',
      'hpp': 'text/x-c++hdr',
      'html': 'text/html',
      'htm': 'text/html',
      'css': 'text/css',
      'scss': 'text/x-scss',
      'sass': 'text/x-sass',
      'json': 'application/json',
      'xml': 'application/xml',
      'yaml': 'application/x-yaml',
      'yml': 'application/x-yaml',
      'md': 'text/markdown',
      'txt': 'text/plain',
      'env': 'text/plain'
    };

    return mimeMap[extension] || 'text/plain';
  }

  /**
   * Build hierarchical file structure
   */
  _buildHierarchy(files) {
    const folderMap = new Map();
    const rootItems = [];

    // Process each file
    for (const file of files) {
      const pathParts = file.filePath.split('/');
      
      if (pathParts.length === 1) {
        // Root level file
        rootItems.push({
          name: file.fileName,
          type: 'file',
          path: file.filePath,
          size: file.fileSize
        });
      } else {
        // Create folder structure
        for (let i = 1; i < pathParts.length; i++) {
          const folderPath = pathParts.slice(0, i).join('/');
          if (!folderMap.has(folderPath)) {
            folderMap.set(folderPath, {
              name: pathParts[i - 1],
              type: 'folder',
              path: folderPath,
              children: []
            });
          }
        }
        
        // Add file to its parent folder
        const parentFolderPath = pathParts.slice(0, -1).join('/');
        if (folderMap.has(parentFolderPath)) {
          folderMap.get(parentFolderPath).children.push({
            name: file.fileName,
            type: 'file',
            path: file.filePath,
            size: file.fileSize
          });
        }
      }
    }

    // Build nested folder structure
    for (const [folderPath, folder] of folderMap) {
      const pathParts = folderPath.split('/');
      
      if (pathParts.length === 1) {
        // Top-level folder
        rootItems.push(folder);
      } else {
        // Nested folder
        const parentPath = pathParts.slice(0, -1).join('/');
        if (folderMap.has(parentPath)) {
          folderMap.get(parentPath).children.push(folder);
        }
      }
    }

    return rootItems;
  }
}

// Create and export singleton instance
module.exports = new PureYjsFileStorageService();
